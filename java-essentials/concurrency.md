# 并发

## Snychronized关键字内部实现
* 对象头锁标志表示当前锁类型：无锁，偏向锁，轻量级锁，重量级锁。
* 偏向锁：对象头记录线程ID，表示该线程锁定
* 轻/重量级锁：对象头指向栈中所对象指针

## 轻重区分：
* 重量级锁：基于操作系统提供的互斥量实现的，需要切换上下文
* 轻量级锁：基于CAS实现的自旋锁

* 锁的膨胀：轻量级锁膨胀为重量级锁的过程

## 加锁过程：（比较繁琐，略）
加锁过程中，随着竞争的激烈，锁会升级：偏向锁->轻量级锁->重量级锁

升级的本质原因，主要考虑性能的优化，轻量级锁（基于CAS的自选锁）是循环等待，避免了线程的切换。轻量级锁适用于短时间的等待，而且这里的“短时间”应该小于线程的启停的时间，否则就得不偿失。如果锁的时间较长，则使用重量级锁比较合理。

* 适应性自选锁（Adaptive Spinning):比普通的自选锁稍微复杂一点，自选次数不是固定的，而是根据自选成功的计数来调整。
* 锁粗化（Lock coarsening）:虚拟机自动检测是否可以合并多次对同一个块的锁定过程，
* 锁消除：虚拟机根据代码逃逸技术，自动检测发现某些数据不会逃逸出当前线程，则自动消除锁操作。

## 问答
1. 自旋锁

自旋的意思就是循环，不断的检查锁是否可用，如果可用就占有。
2. 自旋锁的其他种类
	
都是为了解决多核CPU的问题
*	Tick锁：必须到到主内存读取，阻止其他CPU修改
*	CLH锁：基于队列实现，单向列表。
*	MCS锁：
3. 阻塞锁
	如果资源已经被占用，调用就会被阻塞
4. 可重入锁
	当前线程多次锁定同一个资源，不会阻塞
5. 读写锁
	读锁是共享的，写锁是独占的
6. 互斥锁
	只有2个状态。用于资源只能同时一个线程访问的场景，就是一个排他锁。
7. 悲观锁
	操作资源之前，必须先加锁，操作完以后，释放锁。
8. 乐观锁
	修改数据（CAS原子操作）之前不加锁，但是会判断数据（版本）是否有变化。
9. 公平锁
	先来先得
10. 非公平锁
	锁释放的时候，优先给刚刚来的竞争者，而不是从队列头找阻塞的线程，避免切换线程的开销。
11. 偏向锁
	对象头记录线程ID
12. 对象锁
	Java对象作为锁，使用snychronized关键字实现。
13. 线程锁
14. 锁粗化
	虚拟机自动检测可以合并的锁操作
15. 轻量级锁
	使用CAS原子操作实现的锁
16. 锁消除
	虚拟机通过分析逃逸数据，消除不必要的锁操作。
17. 锁膨胀
	轻量级锁升级为重量级锁
18. 信号量
	用于多线程同步。状态为非负整数。
